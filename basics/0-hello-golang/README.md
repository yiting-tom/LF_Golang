# Hello, Golang!

[toc]

## Define a package
The Hello, Golang script
```go
package main // Define this go script is belong to package `main`

import "fmt"

func main() {
    fmt.Println("Hello, Golang!")
}
```


## Package and $GOPATH
First, we have this project structure.
```
go-exercise
    └─src
        ├─hello
        │   └─hello.go
        │
        └─main
            └─main.go
```
The _src_ directory must be found by `GOROOT` or `GOPATH`.
When a specific package is needed, the go compiler would search from these two paths to get it.
Therefore, for convenience, GOPATH is usually set to the **current workspace** (i.e. `set GOPATH=/the/path/to/your/workspace`).

- hello.go defined by:
  ```go
  pakcage main

  import "hello"  // Import the `hello` package.

  func main() {
      hello.HelloGo() // Using the HelloGo() function in hello package.
  }
  ```

- hello.go defined by:
    ```go
    pakcage hello

    import "fmt"

    func HelloGo() { // The function name must start with an uppercase letter.
        fmt.Println("Hello, Golang!")
    }
    ```
    - If the functions with names that **start with an uppercase letter** will be **exported** to other packages.
    - If the function name **starts with a lowercase letter**, it **won't be exported** to other packages, but you can call this function within the same package.

After executing `go run src/main/main.go` it should display: Hello, Golang!

## 🏗 go build
The `build` command would compile the source code into binary file.
We also could specify where the binary file should be generated by `go build -o bin/main src/main/main.go`

## 📦 go install
The `go build` command would compile from the source code, if the package was compiled before, we could use `go install` to generate your binary file.
For example, after we execute `go install hello`, the file structure would be like this:
```
go-exercise
    ├─bin
    │   └─main.exe
    │
    ├─pkg  <-- Would generate the `pkg\$GOOS_$GOARCH` directory.
    │   └─linux_amd64
    │       └─hello.a
    │
    └─src
        ├─hello
        │   └─hello.go
        │
        └─main
            └─main.go
```
- if execute `go install main` it would generate the **binary file** in *bin*,
- if the package is 3rd-party package, it would generate the **.a file** in _pkg/\$GOOS\_\$GOARCH_

The **.a** file is compiled package, therefore if next time we need to use the same package, and if the package's **.a** file is exists, the go compiler can use it directly without re-compile the entire project 😍.

## 📄 go doc
The `go doc <pkg> <sym>[.<method>]` would display the documentation, like:
```bash
$ go doc fmt.Printf

func Printf(format string, a ...interface{}) (n int, err error)

    Printf formats according to a format specifier and writes to standard
    output. It returns the number of bytes written and any write error
    encountered.
```

## 📏 go fmt
The `go fmt <filename>` could be used to format a specific file.

## 🧪 go test
TODO: